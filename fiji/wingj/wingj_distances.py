#!/usr/bin/python

'''
Process results of WingJ (http://www.tschaffter.ch/) with Imaris objects
(exported from the statistics part to XML) to do distance calculations.
'''

from log import log
import aux
import numpy as np
import volpy as vp
import imaris_xml as ix
import sys
import argparse
import csv


# TODO:
#  - too many arguments (Pylint R0913)
#  - too many local variables (Pylint R0914)
def wingj_dist_to_surfaces(files_wingj, files_out, px_size=1.0,
        file_imsxml=None, file_ijroi=None):
    '''Calculate distances from WingJ structures to spots in 2D.

    Takes the three structure files exported from WingJ containing the A-P, the
    V-D, and the contour line separation coordinates plus an XML file generated
    with Imaris containing objects with coordinates (the "Position" table) or a
    CSV file generated by ImageJ containing "center of mass" coordinates and
    calculates the closest distance from any Imaris object to each of the WingJ
    structures.

    Parameters
    ----------
    files_wingj, files_out : file handles or strings
        3-tuples of file handles or strings with filenames for the WingJ
        structure files.
    file_imsxml, file_ijroi : file handle or string
        A file handle or filename-string to an Imaris XML export.
    px_size : float, optional
        The size of one pixel to correct WingJ coordinates with.

    Returns
    -------
    Nothing, currently results are written to CSV directly.
    '''

    log.info('Reading WingJ CSV files...')
    structure_ap = np.loadtxt(files_wingj[0], delimiter='\t')
    structure_vd = np.loadtxt(files_wingj[1], delimiter='\t')
    structure_cnt = np.loadtxt(files_wingj[2], delimiter='\t')
    log.info('Done.')
    # structure_XX.shape (N, 2)

    if file_imsxml is not None:
        xmldata = ix.ImarisXML(file_imsxml)
        wingpoints = np.array(xmldata.coordinates('Position'))
        # we're working on a projection, so remove the third dimension/column
        wingpoints_2d = np.delete(wingpoints, 2, 1)
    elif file_ijroi is not None:
        log.info('Reading ROI file...')
        roi_tmp = []
        roi_reader = csv.DictReader(aux.check_filehandle(file_ijroi))
        for item in roi_reader:
            roi_tmp.append([item['XM'], item['YM']])
        roi_coords = np.array(roi_tmp, dtype=float)
        log.debug(roi_coords)
        log.info('Done.')
        wingpoints_2d = roi_coords
    else:
        raise AttributeError('no reference file given!')

    # number of objects from coordinates file
    wp_nr = wingpoints_2d.shape[0]

    # calibrate WingJ data
    # px_size = 0.378
    structure_ap *= px_size
    structure_vd *= px_size
    structure_cnt *= px_size

    log.info('Calculating distance matrices for all objects...')
    dists_ap = vp.dist_matrix(np.vstack([wingpoints_2d, structure_ap]))
    dists_vd = vp.dist_matrix(np.vstack([wingpoints_2d, structure_vd]))
    dists_cnt = vp.dist_matrix(np.vstack([wingpoints_2d, structure_cnt]))
    # dists_XX.shape (N+M, N+M)
    log.info('Done.')

    # slice desired parts from the distance matrices: just the rows for all
    # Imaris points ([:wp_nr,:]) and the cols for the WingJ points ([:,wp_nr:])
    wp_to_ap = dists_ap[:wp_nr, wp_nr:]
    wp_to_vd = dists_vd[:wp_nr, wp_nr:]
    wp_to_cnt = dists_cnt[:wp_nr, wp_nr:]
    #  wp_to_XX.shape (M, N)

    # now we can just iterate through all rows finding the minimum and we get
    # the shortest distance for each point to one of the WingJ structures:
    log.info('Finding shortest distances...')
    wp_to_ap_min = np.zeros((wp_nr))
    wp_to_vd_min = np.zeros((wp_nr))
    wp_to_cnt_min = np.zeros((wp_nr))
    for i in range(wp_nr):
        wp_to_ap_min[i] = wp_to_ap[i].min()
        wp_to_vd_min[i] = wp_to_vd[i].min()
        wp_to_cnt_min[i] = wp_to_cnt[i].min()
    log.info('Done.')

    # export the results as CSV files
    log.info('Writing "%s".' % aux.filename(files_out[0]))
    np.savetxt(files_out[0], wp_to_ap_min, delimiter=',')
    log.info('Writing "%s".' % aux.filename(files_out[1]))
    np.savetxt(files_out[1], wp_to_vd_min, delimiter=',')
    log.info('Writing "%s".' % aux.filename(files_out[2]))
    np.savetxt(files_out[2], wp_to_cnt_min, delimiter=',')
    log.info('Finished.')


def main():
    """Parse commandline arguments and run distance calculations."""
    argparser = argparse.ArgumentParser(description=__doc__)
    argparser.add_argument('--ap', required=True, type=file,
        help='WingJ structure file for the A-P separation.')
    argparser.add_argument('--vd', required=True, type=file,
        help='WingJ structure file for the V-D separation.')
    argparser.add_argument('--cnt', required=True, type=file,
        help='WingJ structure file for the contour line.')
    group = argparser.add_mutually_exclusive_group(required=True)
    group.add_argument('--imsxml', type=file, default=None,
        help='Imaris Excel XML export containing a "Position" sheet.')
    group.add_argument('--ijroi', type=file, default=None,
        help='ImageJ CSV export having "center of mass" measurements.')
    argparser.add_argument('--apout', type=argparse.FileType('w'),
        required=True, help='Output CSV file for distances to A-P line.')
    argparser.add_argument('--vdout', type=argparse.FileType('w'),
        required=True, help='Output CSV file for distances to V-D line.')
    argparser.add_argument('--cntout', type=argparse.FileType('w'),
        required=True, help='Output CSV file for distances to contour line.')
    argparser.add_argument('-p', '--pixelsize', required=False, type=float,
        default=1.0, help='Pixel size to calibrate WingJ data.')
    argparser.add_argument('-v', '--verbosity', dest='verbosity',
        action='count', default=0)
    try:
        args = argparser.parse_args()
    except IOError as err:
        argparser.error(str(err))

    aux.set_loglevel(args.verbosity)

    wingj_dist_to_surfaces(
        (args.ap, args.vd, args.cnt),
        (args.apout, args.vdout, args.cntout),
        args.pixelsize, args.imsxml, args.ijroi)


if __name__ == "__main__":
    sys.exit(main())
