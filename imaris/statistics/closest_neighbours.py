#!/usr/bin/python

"""Calculate the closest neighbor to a given spot.

Takes two Excel XML files (generated by Bitplane Imaris) with results
from the spots detection, one file containing just a single spot, the
other file containing many spots. Calculates the spot from the second
file with the closest distance to the one from the first file.
"""

# TODO: do the write only on an explicit call, add informational functions
#   like obj.ref_spots_count() or similar

import argparse
import sys
from ImsXMLlib import ImarisXML
from dist_tools import dist_matrix_euclidean, find_neighbor


class ClosestNeighbours(object):

    def __init__(self, file_ref, file_cand, file_out):
        self.out = file_out.write
        self.ref = file_ref
        self.cand = file_cand
        self._parse()
        self._process()

    def _parse(self):
        self.out('Processing file: ' + str(self.ref.name) + "\n")
        self.XMLref = ImarisXML(self.ref)
        self.out('Processing file: ' + str(self.cand.name) + "\n")
        self.XMLcnd = ImarisXML(self.cand)

        # spots_r are taken as the base to find the closest ones
        # in the set of spots_c
        self.spots_r = self.XMLref.coordinates('Position')
        self.spots_c = self.XMLcnd.coordinates('Position')

    def _process(self):
        self.dist_mat = dist_matrix_euclidean(self.spots_r + self.spots_c)

        ref_mask = [1] * len(self.spots_r) + [0] * len(self.spots_c)

        for refid, refspot in enumerate(self.spots_r):
            nearest = find_neighbor(refid, self.dist_mat, ref_mask)
            self.write_output(refid, refspot, len(self.spots_r), nearest)
        return(0)

    def write_output(self, id_r, coord_r, count_r, id_n):
        ''' "_r" denote the reference spot, "_n" the closest neighbour '''
        id_n_orig = id_n - count_r
        self.out('\nCalculating closest neighbour.\n')
        self.out('Original spot:  [%s] %s\nNeighbour spot: [%s] %s\n' %
            (id_r, coord_r, id_n_orig, self.spots_c[id_n_orig]))
        self.out('Distance: %s\n' % self.dist_mat[id_r, id_n])


def main():
    # main() is only called when we're run directly from the cmdline, so we
    # have to parse the arguments first:
    argparser = argparse.ArgumentParser(description=__doc__)
    argparser.add_argument('-r', '--reference', required=True, type=file,
        help='Imaris Excel XML export containing reference spots.')
    argparser.add_argument('-c', '--candidate', required=True, type=file,
        help='Imaris Excel XML export containing candidate spots.')
    argparser.add_argument('-o', '--outfile', default=sys.stdout,
        type=argparse.FileType('w'), help='File to store the results.')
    try:
        args = argparser.parse_args()
    except IOError as e:
        argparser.error(str(e))

    neighbours = ClosestNeighbours(args.reference, args.candidate,
        args.outfile)

# see http://www.artima.com/weblogs/viewpost.jsp?thread=4829
# for this nice way to handle the sys.exit()/return() calls
if __name__ == "__main__":
    sys.exit(main())
