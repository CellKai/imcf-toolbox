#!/usr/bin/python

"""Calculate the closest neighbor to a given spot.

Takes two Excel XML files (generated by Bitplane Imaris) with results
from the spots detection, one file containing just a single spot, the
other file containing many spots. Calculates the spot from the second
file with the closest distance to the one from the first file.
"""

# TODO:
#  - create a class for handling Excel XML, move to separate package
#  - do sanity checking
#  - evaluate datatypes from XML cells

import argparse
import xml.etree.ElementTree as etree
import sys
import math
import numpy as np
from dist_tools import dist

def parse_xml(infile):
    """Aux function to call the etree parser.

    Just an auxiliary function for debugging statements.
    """
    print "Processing file: " + infile.name
    tree = etree.parse(infile)
    # print "Done parsing the XML."
    # print
    return(tree)

def check_namesp(xml_etree, expected_ns):
    """Check if an XML tree has a certain namespace.

    Takes an XML etree object and a string denoting the expected
    namespace, checks if the namespace of the XML tree matches.
    Returns the namespace if yes, exits otherwise.
    """
    # FIXME: throw an exception or return false instead of exiting
    real_ns = xml_etree.getroot().tag[1:].split("}")[0]
    if not real_ns == expected_ns:
        print "ERROR, this file doesn't have the expected XML namespace!"
        sys.exit(1)
    # print "Namespace parsed from XML document: '" + real_ns + "'"
    # print
    return(real_ns)

def get_worksheet(xml_etree, ns, pattern):
    """Look up a certain worksheet in an Excel XML tree.

    Args:
        xml_etree: etree object
        ns: the XML namespace to use for searching
        pattern: the name of the worksheet

    Returns:
        worksheet: pointer to a subtree of the given etree
    """
    # FIXME: what happens if the worksheet can't be found??
    pattern = ".//{%s}Worksheet[@{%s}Name='%s']" % (ns, ns, pattern)
    worksheet = xml_etree.findall(pattern)
    return(worksheet)

def parse_celldata(worksheet, ns):
    """Parse the cell-contents of a worksheet into a 2D array.

    Args:
        worksheet: the worksheet to process
        ns: the XML namespace

    Returns:
        cells: a 2D array of the form (r=row, c=column):
               [ [r1c1, r1c2, r1c3, ...],
                 [r2c1, r2c2, r2c3, ...],
                 [r3c1, r3c2, r3c3, ...],
                 ...                      ]
    """
    # TODO: error handling
    cells = []
    rows = worksheet.findall('.//{%s}Row' % ns)
    for row in rows:
        content = []
        # check if this is a header row:
        style_att = '{%s}StyleID' % ns
        if style_att in row.attrib:
            # currently we don't process the header rows, so skip to the next
            continue
        # print str(len(row))
        for cell in row:
            content.append(cell[0].text)
        # print content
        cells.append(content)
    # print cells
    # print "Parsed rows: " + str(len(cells))
    return(cells)

def IMS_extract_coords(table_cells):
    """Extract Imaris-style coordinates and ID's from a cell array.

    Args:
        table_cells: 2D array with the cell contents of a worksheet.

    Returns:
        coords: array using the ID as index, storing 3-tuples of floats
                representing the coordinates in (x, y, z) order.
    """
    coords = []
    # extract positions and ID:
    for cell in table_cells:
        id = int(cell[7])
        x = float(cell[0])
        y = float(cell[1])
        z = float(cell[2])
        coords.insert(id, (x, y, z))
    # print "Parsed coordinates:", str(len(coords))
    return(coords)

def main():
    argparser = argparse.ArgumentParser(description=__doc__)
    argparser.add_argument('-s', '--single', required=True, type=file,
        help='Excel XML file containing a single spot.')
    argparser.add_argument('-m', '--multi', required=True, type=file,
        help='Excel XML file containing multiple spots.')
    try:
        args = argparser.parse_args()
    except IOError as e:
        argparser.error(str(e))

    tree1 = parse_xml(args.single)
    myns = check_namesp(tree1, 'urn:schemas-microsoft-com:office:spreadsheet')

    tree2 = parse_xml(args.multi)
    myns = check_namesp(tree2, 'urn:schemas-microsoft-com:office:spreadsheet')

    # we're looking for stuff in the "Position" worksheet:
    ws1_pos = get_worksheet(tree1, myns, 'Position')
    ws2_pos = get_worksheet(tree2, myns, 'Position')

    cells1 = parse_celldata(ws1_pos[0], myns)
    cells2 = parse_celldata(ws2_pos[0], myns)

    # reference_spots are taken as the base to find the closest ones
    # in the set of cand_spots
    reference_spots = IMS_extract_coords(cells1)
    cand_spots = IMS_extract_coords(cells2)

    # test if calculation seems to be plausible:
    # cand_spots[len(cand_spots) - 1] = (59.84, 25.602, 1.161)

    for refid, refspot in enumerate(reference_spots):
        # create a numpy array for the distances to all spots in file1
        distances = np.empty(len(cand_spots))
        print
        print 'Calculating closest neighbour.'
        print 'Original spot:  [' + str(refid) + ']', refspot
        for idx, candspot in enumerate(cand_spots):
            distances[idx] = dist(refspot, candspot)
        nearest = distances.argmin()
        print "Neighbour spot: [" + str(nearest) + ']', cand_spots[nearest]
        print "Distance:", distances[nearest]
    return(0)

# see http://www.artima.com/weblogs/viewpost.jsp?thread=4829
# for this nice way to handle the sys.exit()/return() calls
if __name__ == "__main__":
    sys.exit(main())
