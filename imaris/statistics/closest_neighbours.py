#!/usr/bin/python

"""Calculate the closest neighbor to a given spot.

Takes two Excel XML files (generated by Bitplane Imaris) with results
from the spots detection, one file containing just a single spot, the
other file containing many spots. Calculates the spot from the second
file with the closest distance to the one from the first file.
"""

import argparse
import sys
from ImsXMLlib import ImarisXML
from dist_tools import dist_matrix_euclidean, find_neighbor


class ClosestNeighbours(object):

    def __init__(self, file_ref, file_cand, file_out):
        self.out = file_out.write
        self.ref = file_ref
        self.cand = file_cand
        self._parse()
        self._process()

    def _parse(self):
        self.out('Processing file: ' + str(self.ref.name) + "\n")
        self.XMLref = ImarisXML(self.ref)
        self.out('Processing file: ' + str(self.cand.name) + "\n")
        self.XMLcnd = ImarisXML(self.cand)

        # ref_spots are taken as the base to find the closest ones
        # in the set of cand_spots
        self.ref_spots = self.XMLref.coordinates('Position')
        self.cand_spots = self.XMLcnd.coordinates('Position')

    def _process(self):
        self.dist_mat = dist_matrix_euclidean(self.ref_spots + self.cand_spots)

        ref_mask = [1] * len(self.ref_spots) + [0] * len(self.cand_spots)

        for refid, refspot in enumerate(self.ref_spots):
            nearest = find_neighbor(refid, self.dist_mat, ref_mask)
            self.write_output(refid, refspot, len(self.ref_spots), nearest)
        return(0)

    def write_output(self, id_ref, coord_ref, count_refs, id_neigh):
            nearest_orig_id = id_neigh - count_refs
            self.out("\nCalculating closest neighbour.\n")
            self.out('Original spot:  [' + str(id_ref) + '] ' + str(coord_ref) + "\n")
            self.out('Neighbour spot: [' + str(nearest_orig_id) + '] ' + \
                str(self.cand_spots[nearest_orig_id]) + "\n")
            self.out("Distance: " + str(self.dist_mat[id_ref, id_neigh]) + "\n")

def main():
    # main() is only called when we're run directly from the cmdline, so we
    # have to parse the arguments first:
    argparser = argparse.ArgumentParser(description=__doc__)
    argparser.add_argument('-r', '--reference', required=True, type=file,
        help='Imaris Excel XML export containing reference spots.')
    argparser.add_argument('-c', '--candidate', required=True, type=file,
        help='Imaris Excel XML export containing candidate spots.')
    argparser.add_argument('-o', '--outfile', default=sys.stdout,
        type=argparse.FileType('w'), help='File to store the results.')
    try:
        args = argparser.parse_args()
    except IOError as e:
        argparser.error(str(e))

    neighbours = ClosestNeighbours(args.reference, args.candidate,
        args.outfile)

# see http://www.artima.com/weblogs/viewpost.jsp?thread=4829
# for this nice way to handle the sys.exit()/return() calls
if __name__ == "__main__":
    sys.exit(main())
