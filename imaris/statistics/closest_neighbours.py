#!/usr/bin/python

"""Calculate the closest neighbor to a given spot.

Takes two Excel XML files (generated by Bitplane Imaris) with results
from the spots detection, one file containing just a single spot, the
other file containing many spots. Calculates the spot from the second
file with the closest distance to the one from the first file.
"""

# TODO: make the code more usable as an object:
#   [1] do the write only on an explicit call
#   [2] add informational functions like obj.ref_spots_count() or similar

import argparse
import sys
import csv
from ImsXMLlib import ImarisXML
from volpy import dist_matrix, find_neighbor
from numpy import delete


class ClosestNeighbours(object):

    def __init__(self, file_ref, file_cand, file_out):
        self.out = sys.stdout.write
        self.csvout = False
        if (file_out.name != '<stdout>'):
            self.csv = csv.writer(file_out)
            self.csvout = True
        self.ref = file_ref
        self.cand = file_cand
        self._parse()
        self._process()

    def _parse(self):
        self.out('Processing file: ' + str(self.ref.name) + "\n")
        self.XMLref = ImarisXML(self.ref)
        # for more verbosity, add 'debug=2' to the ImarisXML call
        self.out('Processing file: ' + str(self.cand.name) + "\n")
        self.XMLcnd = ImarisXML(self.cand)

        # spots_r are taken as the base to find the closest ones
        # in the set of spots_c
        self.spots_r = self.XMLref.coordinates('Position')
        self.spots_c = self.XMLcnd.coordinates('Position')

    def _process(self):
        self.dist_mat = dist_matrix(self.spots_r + self.spots_c)
        self.out("Reference objects: %s\n" % len(self.spots_r))
        self.out("Candidate objects: %s\n" % len(self.spots_c))
        dists_to_ref = self.dist_mat[:][0]
        dists_to_ref = delete(dists_to_ref, 0, 0)
        if (self.csvout):
            # print dists_to_ref
            self.out('Writing CSV...\n')
            for i, line in enumerate(dists_to_ref):
                # output = "%i,%f" % (i, line)
                # print output
                self.csv.writerow([i, line])

        ref_mask = [1] * len(self.spots_r) + [0] * len(self.spots_c)

        for refid, refspot in enumerate(self.spots_r):
            nearest = find_neighbor(refid, self.dist_mat, ref_mask)
            # TODO [1]
            self.write_output(refid, refspot, len(self.spots_r), nearest)
        return(0)

    def write_output(self, id_r, coord_r, count_r, id_n):
        ''' "_r" denote the reference spot, "_n" the closest neighbour '''
        id_n_orig = id_n - count_r
        self.out('\nCalculating closest neighbour.\n')
        self.out('Reference: \t\t[%s]\t%s\nClosest neighbour: \t[%s]\t%s\n' %
            (id_r, coord_r, id_n_orig, self.spots_c[id_n_orig]))
        self.out('Distance: %s\n' % self.dist_mat[id_r, id_n])


def main():
    # main() is only called when we're run directly from the cmdline, so we
    # have to parse the arguments first:
    argparser = argparse.ArgumentParser(description=__doc__)
    argparser.add_argument('-r', '--reference', required=True, type=file,
        help='Imaris Excel XML export containing reference spots.')
    argparser.add_argument('-c', '--candidate', required=True, type=file,
        help='Imaris Excel XML export containing candidate spots.')
    # argparser.add_argument('-o', '--outfile', default=sys.stdout,
        # type=argparse.FileType('w'), help='File to store the results.')
    argparser.add_argument('--csv', default=sys.stdout,
        type=argparse.FileType('w'), help='CSV-file to store the results.')
    argparser.add_argument('-v', '--verbose', dest='v',
        action='count', default=0)
    try:
        args = argparser.parse_args()
    except IOError as e:
        argparser.error(str(e))

    neighbours = ClosestNeighbours(args.reference, args.candidate,
        args.csv)

# see http://www.artima.com/weblogs/viewpost.jsp?thread=4829
# for this nice way to handle the sys.exit()/return() calls
if __name__ == "__main__":
    sys.exit(main())
