#!/usr/bin/python

"""Calculate the closest neighbor to a given spot.

Takes two Excel XML files (generated by Bitplane Imaris) with results from the
spots detection, one file containing just a single spot, the other file
containing many spots. Calculates the spot from the second file with the
closest distance to the one from the first file.
"""

import argparse
import sys
import csv
from ImsXMLlib import ImarisXML
from volpy import dist_matrix, find_neighbor
from numpy import delete
from log import log
from aux import set_loglevel


def print_summary(edm, spots_c, spots_r, id_r, id_n):
    """Print summary of results.

     Arguments
     ---------
     edm : the euclidean distance matrix
     spots_c : the list of candidate spots
     id_r, count_r, count_r : reference spot
     id_n : index number of closest neighbour
     """
    log.warn('\nCalculating closest neighbour.')
    log.warn('Reference: \t\t[%s]\t%s' % (id_r, spots_r[id_r]))
    log.warn('Closest neighbour: \t[%s]\t%s' % (id_n, spots_c[id_n]))
    log.warn('Distance: %s' % edm[id_r, id_n + len(spots_r)])


def parse_arguments():
    """Parse the commandline arguments."""
    argparser = argparse.ArgumentParser(description=__doc__)
    argparser.add_argument('-r', '--reference', required=True, type=file,
        help='Imaris Excel XML export containing reference spots.')
    argparser.add_argument('-c', '--candidate', required=True, type=file,
        help='Imaris Excel XML export containing candidate spots.')
    # argparser.add_argument('-o', '--outfile', default=sys.stdout,
        # type=argparse.FileType('w'), help='File to store the results.')
    argparser.add_argument('--csv', default=sys.stdout,
        type=argparse.FileType('w'), help='CSV-file to store the results.')
    argparser.add_argument('-v', '--verbosity', dest='verbosity',
        action='count', default=0)
    try:
        return argparser.parse_args()
    except IOError as err:
        argparser.error(str(err))


def closest_neighbours(in_ref, in_cnd, out_csv):
    """Calculate the closest neighbours of given reference spots."""
    xml_ref = ImarisXML(in_ref)
    xml_cnd = ImarisXML(in_cnd)
    log.warn('References file: %s' % in_ref.name)
    log.warn('Candidates file: %s' % in_cnd.name)

    # spots_r are taken as the base to find the closest ones
    # in the set of spots_c
    spots_r = xml_ref.coordinates('Position')
    spots_c = xml_cnd.coordinates('Position')
    log.warn("Reference objects: %s" % len(spots_r))
    log.warn("Candidate objects: %s" % len(spots_c))

    dist_mat = dist_matrix(spots_r + spots_c)
    dists_to_ref = dist_mat[:][0]
    log.info("Distances to reference:\n%s" % dists_to_ref)
    dists_to_ref = delete(dists_to_ref, 0, 0)
    if (out_csv.name != '<stdout>'):
        log.warn("Writing results to '%s'" % out_csv.name)
        csvout = csv.writer(out_csv)
        for i, line in enumerate(dists_to_ref):
            csvout.writerow([i, line])

    # create a mask to ignore the reference spots
    ref_mask = [1] * len(spots_r) + [0] * len(spots_c)
    for refid in range(len(spots_r)):
        # the result of find_neighbor() must be adjusted by the length of the
        # spots_r list to retrieve the index number for the spots_c list:
        nearest = find_neighbor(refid, dist_mat, ref_mask) - len(spots_r)
        print_summary(dist_mat, spots_c, spots_r, refid, nearest)


def main():
    """Parse the commandline and dispatch the calculations."""
    args = parse_arguments()
    set_loglevel(args.verbosity)
    closest_neighbours(args.reference, args.candidate, args.csv)

if __name__ == "__main__":
    sys.exit(main())
